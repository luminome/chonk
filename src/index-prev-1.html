<!DOCTYPE html>
<!--https://scottandrecampbell.com/static/jan7-1.html?ok-->
<!--https://www.toptal.com/javascript/comprehensive-guide-javascript-design-patterns-->
<!--https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec-->
<!--https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management-->

<html lang="en">
<head>
	<title>chonky jan20-1 sac</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./css/basic.css">
	<!--		<script src="js/vendor/modernizr-3.11.2.min.js"></script>-->
	<style>
		svg {
			display: block;
		}

		#nav_bar {
			position: absolute;
			height: 24px;
			bottom: 0;
			left: 0;
			right: 0;
			display: block;
			background-color: black;
			margin: 0;
			padding: 0;
			/*opacity:0.5;*/
		}

		#load_bar {
			position: absolute;
			height: 1px;
			left: 0;
			bottom: 24px;
			width: 100px;
			background: repeating-linear-gradient(to right, greenyellow 0, greenyellow 10px, transparent 10px, transparent 12px);

		}

		#info {
			position: absolute;
			color: greenyellow;
			font-family: heavy_data, sans-serif;
			/*font-variant-numeric: tabular-nums lining-nums;*/
			bottom: 24px;
			overflow: visible;
			font-size: 9px;
			line-height: 12px;
			padding: 8px;
			background-color: #11113380;
		}


		#layers_ui {
			position: absolute;
			font-family: heavy_data, sans-serif;
			font-size: 12px;
			line-height: 18px;
			padding: 8px;
			background-color: #11113380;
		}

		.menu_default{
			color: darkgray;
		}

		.menu_selected {
			color: white;
		}

		.submenu_default{
			color: darkslategrey;
		}

		.submenu_selected {
			color: yellowgreen;
		}

		.template {
			display:none;
		}

		.menuheaderlabel {
			position:relative;
			padding-right: 30px;
		}

		.menuheaderlabel:hover {
			cursor:pointer;
		}

		.menu_visible {
			display:block;
		}

		.menu_hidden{
			display:none;
		}

		.menuspecial {
			/*display:block;*/
		}
		.menukey {
			/*display:none;*/
		}




		.menuctrl {
			height:inherit;
			position: absolute;
			top:0px;
			right:0px;

		}

		.highlited{
			color:white;
		}

		.var{

		}

		.var-bar{

		}

		.var-text{
			font-family: heavy_data, sans-serif;
			font-size: 12px;
			background-color: #11113380;
			border:none;
			color:white;
		}

		.var-text:focus {
			outline: none !important;
			border:none;
			/*box-shadow: 0 0 10px #719ECE;*/
		}

		.menuspecial, .menukey, .var-text{
			padding-left:4px;
			padding-right:4px;
		}

		.menu-item-var {
			color:dodgerblue;
		}
		.svg_text {
			color: greenyellow;
			font-family: heavy_data, sans-serif;
		}

	</style>
</head>
<body>
<div id="info"></div>
<div id="layers_ui">

	<div id="variable_setter_temp" class="template">
		<input class="var-text" type="text" size="6">
	</div>

	<div id="menu_header_temp" class="menuheaderlabel template">
		<div class="menulabel"></div>
		<div class="menuctrl">
			<span class="menukey">x</span>
			<span class="menuspecial">x</span>
		</div>
	</div>

</div>
<div id="nav_bar">
	<svg id="nav_svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"/>
</div>
<div id="load_bar"></div>
<script type="module">

	import {dragControls} from './js/drags.js';
	import {keyControls} from './js/keys.js';
	import * as THREE from 'three/build/three.module.js';///build/three.module.js'; ONLY ONCE
	import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';
	import Stats from 'three/examples/jsm/libs/stats.module.js';
	import {SVGLoader} from 'three/examples/jsm/loaders/SVGLoader.js';
	import {mergeBufferGeometries, mergeVertices} from 'three/examples/jsm/utils/BufferGeometryUtils.js';
	import {data_loader as fetchAll} from './js/data-loader.js';

	import * as UTIL from './js/utilities.js';
	import * as MATS from './js/materials.js';
	import * as classes from './js/classes.js';
	import * as methods from './js/ui_methods.js';
	import {vars} from './js/vars.js';


	"use strict";
	const nav_bar_offset = 24;
	const svgNS = "http://www.w3.org/2000/svg";
	const svg = document.getElementById("nav_svg");
	const loader = document.getElementById("load_bar");
	svg.setAttributeNS(null, 'width', window.innerWidth);
	svg.setAttributeNS(null, 'height', nav_bar_offset);

	function createRect(tag_id, color, width, opacity) {
		let rect = document.createElementNS(svgNS, 'rect');
		rect.setAttributeNS(null, 'id', tag_id);
		rect.setAttributeNS(null, 'x', (width / -2));
		rect.setAttributeNS(null, 'y', 0);
		rect.setAttributeNS(null, 'width', width);
		rect.setAttributeNS(null, 'height', nav_bar_offset);
		rect.setAttributeNS(null, 'fill', color);
		rect.setAttributeNS(null, 'opacity', opacity);
		rect.setAttributeNS(null, 'href', 'http://www.google.com');
		rect.setAttributeNS(svgNS, 'data-wid', width);
		svg.appendChild(rect);
	}

	function createText() {
		let newText = document.createElementNS(svgNS, "text");
		newText.setAttributeNS(null, 'id', 'nav_info');
		newText.setAttributeNS(null, "x", 8);
		newText.setAttributeNS(null, "y", nav_bar_offset - 8);
		newText.setAttributeNS(null, "fill", 'greenyellow');
		newText.setAttributeNS(null, "class", 'svg_text');
		// newText.setAttributeNS(null,"width","100%");
		newText.setAttributeNS(null, "height", "auto");
		newText.setAttributeNS(null, "font-size", "9");
		newText.appendChild(document.createTextNode('hello'));
		// add the text node to the SVG element
		svg.appendChild(newText);
	}

	let nav_bar_pos = 0.5;
	let nav_origin = 0.5;
	let nav_zero = 0.5;

	function update_nav_position(U_pos) {
		let r_mark = svg.childNodes[0];
		let p = window.innerWidth * 0.5;//U_pos;
		nav_bar_pos = U_pos;
		r_mark.setAttributeNS(null, 'x', p - 2);//(p-3).toString());
	}

	createRect('svg_center', 'gray', 4, 1);
	createRect('svg_origin', 'orange', 6, 1);
	createRect('svg_zero', 'white', 2, 0.2);

	const svg_center = svg.getElementById("svg_center");
	const svg_origin = svg.getElementById("svg_origin");
	const svg_zero = svg.getElementById("svg_zero");

	let user_nav_position = 0;
	let user_nav_guide_length = 0;
	let user_slide_scale = 0;

	const el_width = (e) => parseFloat(e.getAttributeNS(svgNS, 'data-wid')) / 2;

	function create_landmark(position, scale, name, pid) {
		let circle = document.createElementNS(svgNS, 'circle');
		circle.setAttributeNS(null, 'cx', 10);
		circle.setAttributeNS(null, 'cy', nav_bar_offset / 2);
		circle.setAttributeNS(null, 'r', 2 + ((4 - scale) / 2) * 2);//(4/scale)*2);
		circle.setAttributeNS(null, 'style', 'fill: yellow; stroke: black; stroke-width: 0.5px;');
		circle.setAttributeNS(svgNS, 'data-name', name);
		circle.setAttributeNS(svgNS, 'data-id', pid);
		circle.setAttributeNS(svgNS, 'data-wid', 2 + ((4 - scale) / 2) * 4);
		circle.setAttributeNS(svgNS, 'data-pos-scalar', position);
		circle.setAttributeNS(svgNS, 'data-pos-offset', position);
		//console.log(name, position);
		return circle;
	}

	function nav_update_guide_places(guide_data_obj) {
		//console.log(vars.user.guide_position_scalar);
		let guide_id = guide_data_obj.userData.guide.shape;
		let nav_guide = svg.getElementById(guide_id + '-guide');
		if (!nav_guide) nav_build_guide_places(guide_id);
		nav_guide = svg.getElementById(guide_id + '-guide');

		let places = guide_data_obj.userData.guide.linked_places;
		let rip_stop = 0;
		let len = nav_guide.getAttributeNS(svgNS, 'data-indexed');
		if (len !== null) {
			if (len < places.length) {
				rip_stop = len;
			}
		}
		nav_guide.setAttributeNS(svgNS, 'data-indexed', places.length);
		let zp = user_nav_position - 0.5;
		zp = UTIL.naturalize_on_loop(zp, true);
		for (let i = rip_stop; i < places.length; i++) {
			const p = places[i];
			let position = p.position;
			let scale = p.place.scale;
			const circle = create_landmark(position, scale, p.place.name, i);
			let ps = zp - position;
			ps = UTIL.naturalize_on_loop(ps, true);
			circle.setAttributeNS(null, 'cx', (window.innerWidth * ps));
			circle.setAttributeNS(svgNS, 'data-pos-offset', ps);
			nav_guide.appendChild(circle);
		}
	}

	function nav_build_guide_places(guide_shape_id) {
		let group = document.createElementNS(svgNS, 'g');
		group.setAttributeNS(null, 'id', guide_shape_id + '-guide');
		group.setAttributeNS(null, 'class', 'guide_places');
		group.setAttributeNS(null, 'x', 0);
		group.setAttributeNS(null, 'y', 0);
		group.setAttributeNS(null, 'width', window.innerWidth);
		group.setAttributeNS(null, 'height', nav_bar_offset);
		group.style.display = 'none';
		svg.appendChild(group);
	}

	function set_guide_position_to_nav_bar(pos_scalar, overall_length) {
		const the_guide = get_guide(vars.user.selected_guide);
		//nav_update_guide_places(the_guide);
		let zp = pos_scalar - 0.5;
		zp = UTIL.naturalize_on_loop(zp, true);
		const boxArray = [...svg.getElementsByTagName('g')];
		for (let g of boxArray) g.style.display = "none";

		let guide_places = svg.getElementById(the_guide.userData.guide.shape + '-guide');
		if (guide_places) {

			guide_places.style.display = "block";


			for (let p of guide_places.childNodes) {
				let ps = zp - parseFloat(p.getAttributeNS(svgNS, 'data-pos-scalar')); //(pos_scalar-0.5)-
				ps = UTIL.naturalize_on_loop(ps, true);
				p.setAttributeNS(null, 'cx', (window.innerWidth * ps));//-(el_width(p)));
				p.setAttributeNS(svgNS, 'data-pos-offset', ps);
			}
		}
		user_nav_guide_length = overall_length * UTIL.km_deg;
		user_slide_scale = window.innerWidth / user_nav_guide_length;
		user_nav_position = pos_scalar;

		nav_origin = 0.5;
		nav_zero = zp;

		svg_zero.setAttributeNS(null, 'x', (window.innerWidth * nav_zero) - (el_width(svg_zero)));
		svg_origin.setAttributeNS(null, 'x', (window.innerWidth * nav_origin) - (el_width(svg_origin)));

	}

	update_nav_position(0.5);

	const nav_info = svg.getElementById("nav_info");

	function update_nav(offset_amount) {
		nav_zero += offset_amount;
		nav_origin += offset_amount;
		nav_zero = UTIL.naturalize_on_loop(nav_zero, true);
		nav_origin = UTIL.naturalize_on_loop(nav_origin, true);

		svg_origin.setAttributeNS(null, 'x', (window.innerWidth * nav_origin) - (el_width(svg_origin)));
		svg_zero.setAttributeNS(null, 'x', (window.innerWidth * nav_zero) - (el_width(svg_zero)));

		user_nav_position += offset_amount;
		user_nav_position = UTIL.naturalize_on_loop(user_nav_position, true);

		const guide_places = svg.getElementById(vars.user.selected_guide + '-guide');
		if (guide_places) {
			for (let p of guide_places.childNodes) {
				let ps = parseFloat(p.getAttributeNS(svgNS, 'data-pos-offset'));
				ps += offset_amount;
				ps = UTIL.naturalize_on_loop(ps, true);
				p.setAttributeNS(null, 'cx', (window.innerWidth * ps));//-(el_width(p)));
				p.setAttributeNS(svgNS, 'data-pos-offset', ps);
			}
		}

		//nav_info.childNodes[0].nodeValue = user_nav_guide_length.toFixed(2)+'km '+user_nav_position.toFixed(2)+' '+nav_selected_guide;
	}

	function svg_interact(type, deltaX, deltaY, object, event) {
		if (type === 'drag') {
			let ost = vars.view_flip ? 1 : -1;
			let offset = (deltaX / window.innerWidth) * (user_slide_scale) * ost;

			update_nav(offset);

			move_point_on_curve(user_nav_position, false);
			//scroll_phi_theta(nav_bar_pos,false);
			//console.log(type,deltaX);
		} else if (type === 'clicked') {
			let ost = vars.view_flip ? 1 : -1;
			let offset = ((deltaX / window.innerWidth) - 0.5) * (-1);

			update_nav(offset);

			move_point_on_curve(user_nav_position, false);

		} else if (type === 'move') {
			//console.log(event.target.tagName);
			if (event.target.tagName === 'circle') {
				const the_guide = get_guide(vars.user.selected_guide);
				let pid = event.target.getAttributeNS(svgNS, 'data-id');
				let p = the_guide.userData.guide.linked_places[pid];
				//log.place.echo(event.target.getAttributeNS(svgNS, 'data-id'));
				log.nav.echo([p.place.name, p.place.locale, '(' + p.place.country + ')']);
			}

		} else {
			if(log.nav) log.nav.unwatch();
		}
	}

	dragControls(svg, svg_interact, svg, {passive: true});//camera_position


	const log_field = document.getElementById('info');

	let log = {};
	let log_new = false;

	function log_display() {
		if (!log_new) return;
		log_field.innerHTML = '';
		for (const l in log) {
			let obj = log[l];
			if (obj.watch) {
				let lines_array = obj.val;
				log_field.innerHTML += '<b class="highlited">' + obj.name + '</b></br>';
				if (lines_array) {
					for (let li of lines_array) {
						log_field.innerHTML += (li === undefined ? 'undefined' : li) + '</br>';//.toString()
					}
				}
			}
		}
		log_new = false;
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	class log_var {
		constructor(name, initial = null) {
			this.name = name;
			this.val = initial;
			this.watch = null;
		}

		echo(val) {
			if (val !== this.val) log_new = true;
			this.val = val;
			this.watch = true;
		}

		unwatch() {
			this.watch = null;
		}
	}


	const ui_el = document.getElementById("layers_ui");


	////`${name}`
	const state_keys_magic = {
		move: function (o) {
			const flip = vars.view_flip ? o : o*-1;
			move_point_on_curve(flip, true);
		},
		guides: function (o) {
			map_guides.visible = o;
			map_guides_verts.visible = o;
		},
		general: function(state, name, v=null){
			map_tiles_group.children.filter(t => t.hasOwnProperty(name)).forEach(t => t[name].visible = state);
		},
		vars_bool: function(state, name, value){
			vars[name] = state;
		},
		vars_number: function(state, name, value){
			console.log(state, name, value);
			vars[name] = parseFloat(value);
		},
		sectors: function (o) {
			map_tiles_group.visible = o;
		},
		grid: function (o) {
			map_points.visible = o;
		},
		map_grid: function (o) {
			gridHelper.visible = o;
		},
		planes: function (o) {
			map_tiles_group.children.forEach(t => t.plane.visible = o);
		},
		fills: function (o) {
			map_tiles_group.children.forEach(t => t.fills.visible = o);
		},
		lines: function (o) {
			map_tiles_group.children.forEach(t => { if(t.hasOwnProperty('lines')) t.lines.visible = o; });
		},
		places: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('places')).forEach(t => { if(t.hasOwnProperty('places')) t.places.visible = o; })
		},
		urban: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('urban')).forEach(t => { if(t.hasOwnProperty('urban')) t.urban.visible = o; })
		},
		protected_regions: function (o) {
			map_tiles_group.children.forEach(t => { if(t.hasOwnProperty('protected_regions')) t.protected_regions.visible = o; })
		},
		depth_points: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('depth_points')).forEach(t => t.depth_points.visible = o);
		},
		contours: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('contours')).forEach(t => t.contours.visible = o);
		},
		sst: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('sst')).forEach(t => t.sst.visible = o);
		},
		wind: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('wind')).forEach(t => t.wind.visible = o);
		},
		wudi: function (o) {
			map_tiles_group.children.filter(t => t.hasOwnProperty('wudi')).forEach(t => t.wudi.visible = o);
		},
		abstract: function (o) {
			//console.log(cube.rotation);
			if (o) {
				cube.userData.last_rotation = cube.rotation.clone();
				cam_base_pos.set(0, 0, vars.view.base_pos);
				cube.rotation.set(Math.PI / -2, 0, 0);
			} else {
				if (cube.userData.hasOwnProperty('last_rotation')) {
					const fr = cube.userData.last_rotation;
					cube.rotation.set(fr._x, fr._y, fr._z);
				}
				cam_base_pos.set(0, 0, 10);
			}
		},
		view_flip: function (o) {
			vars.view_flip = o;
		},
		view_to_threshold: function (o) {
			vars.view_to_threshold = o;
		},

	}

	let menus = {};

	//console.log(menus);


	let gui, camera, scene, renderer, stats, cube, raycaster, user_position_marker, user_mouse_marker, nice_arrow, nice_arrow_mini;
	let axis_helper, grid_helper, arrow_helper, arrow_helper_2, arrow_helper_3, markers_group, north_mark;
	let map_tiles_group, map_group, map_plane, map_points, map_guides, map_guides_verts;
	let state_keys, gen_keys;
	let gridHelper;
	let load_counter = 0;
	let load_scope = 0;


	map_group = new THREE.Group();
	map_tiles_group = new THREE.Group();


	//handle camera
	const cube_box = new THREE.BoxGeometry(2, 2, 2);
	cube = new THREE.Mesh(cube_box, new THREE.MeshStandardMaterial({color: 0xffffff}));
	cube.rotateX(Math.PI / -2);

	let cam_base_pos = new THREE.Vector3(0, 0, vars.view.base_pos);
	let cam_pos = new THREE.Vector3(0, vars.view.base_pos, 0);

	const camera_frustum = new THREE.Frustum();
	const camera_frustum_m = new THREE.Matrix4();

	const w = new THREE.Vector3();
	const k = new THREE.Vector3();
	const v = new THREE.Vector3();
	const u = new THREE.Vector3(0, 1, 0);
	const un = new THREE.Vector3(0, 0, 1);
	const v_q = new THREE.Quaternion();
	const color = new THREE.Color();

	axis_helper = new THREE.AxesHelper(10);
	grid_helper = new THREE.GridHelper(vars.grid_size, vars.grid_divisions);

	const dir = new THREE.Vector3(0, 0, 1);
	const origin = new THREE.Vector3(0, 0, 0);
	const length = 2;
	let hex = 0xFFFF00;
	arrow_helper = new THREE.ArrowHelper(dir, origin, length, hex);
	arrow_helper.visible = true;
	arrow_helper_2 = new THREE.ArrowHelper(dir, origin, length * 0.5, hex);
	arrow_helper_2.visible = true;
	arrow_helper_3 = new THREE.ArrowHelper(dir, origin, length * 0.5, hex);
	arrow_helper_3.visible = true;


	function show_load(i){
		load_scope = load_counter+i > load_counter ? load_counter+i : load_scope;
		load_counter += i;
		if(load_counter === 0) load_scope = 0;
		const ost = load_scope > 0 ? load_counter / load_scope : 0;
		const seg = Math.floor(window.innerWidth / load_scope);
	  const arm = `repeating-linear-gradient(to right, greenyellow 0, greenyellow ${seg-2}px, transparent ${seg}px, transparent ${seg+2}px)`;
		loader.style.width = (ost*window.innerWidth)+'px'.toString();
		loader.style.background = arm;
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	const get_guide = (g_num) => map_guides.children.find(g => g.userData.guide.shape === g_num);
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	// SCENE BUILDING:
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function map_guides_resolve_places(place_node, tile_number) {
		const clone = Object.assign({}, place_node);
		k.set(clone.loc[0], clone.loc[1], 0.0);

		let set = map_tiles_group.children[tile_number].intersects_shapes;
		let places_count = 0;
		for (let l of set) {
			const c_pos = get_point_on_curve(k, l);
			if (c_pos[0]) {
				const the_guide = get_guide(l);
				const p_obj = {
					'position': c_pos[0],
					'place': clone,
					'uid': places_count
				}
				places_count++;
				the_guide.userData.guide.linked_places.push(p_obj);
				nav_update_guide_places(the_guide);
			}
		}
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function make_user_position_mark(radius) {
		const curve = new THREE.EllipseCurve(
			0, 0,            // ax, aY
			radius, radius,           // xRadius, yRadius
			0, 2 * Math.PI,  // aStartAngle, aEndAngle
			true,            // aClockwise
			0                 // aRotation
		);

		curve.updateArcLengths();

		const points = curve.getPoints(201);
		const geometry = new THREE.BufferGeometry().setFromPoints(points);

		const material = new THREE.LineDashedMaterial({
			color: 0x00FF00,
			linewidth: 1,
			scale: 1,
			dashSize: 0.1,
			gapSize: 0.1,
		});

		// Create the final object to add to the scene
		const line = new THREE.Line(geometry, material);
		line.userData.radius = radius;
		line.computeLineDistances();
		line.rotateX(Math.PI / 2);
		return line;

	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function make_pointer_arrow() {
		let points = [];
		const raw_points = [
			0, 0,
			10, 20,
			6, 20,
			7, 32,
			0, 32
		];

		for (let e = 0; e < raw_points.length; e += 2) {
			points.push(new THREE.Vector2(raw_points[e], raw_points[e + 1]));
		}

		const a_geometry = new THREE.LatheGeometry(points, 20);
		const a_material = new THREE.MeshStandardMaterial({
			color: 0xFF3300,
			side: THREE.FrontSide,
			flatShading: true,
			roughness: 0,
			metalness: 0.25,
			emissive: 0x161616
		});
		//const a_material = new MeshStandardMaterial( { color: 0xffff00 } );
		const arrow = new THREE.Mesh(a_geometry, a_material);
		arrow.userData.base_color = arrow.material.color;
		arrow.material.needsUpdate = true;

		arrow.scale.set(0.02, 0.02, 0.02);
		return arrow;

	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function make_markers_group() {
		markers_group = new THREE.Group();
		const markes_count = 10;
		for (let n = 0; n < markes_count; n++) {
			const verts = new Float32Array(18);
			let int = (Math.PI * 2) / 6;
			for (let i = 0; i < verts.length; i += 3) {
				verts[i] = Math.cos((i / 3) * int);
				verts[i + 1] = Math.sin((i / 3) * int);
				verts[i + 2] = 0.0;
			}
			const a_geometry = new THREE.BufferGeometry();
			a_geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3));
			a_geometry.setIndex([0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3]);
			const hexagon = new THREE.Mesh(a_geometry, MATS.mapMarkersMaterial);
			hexagon.rotateX(Math.PI / -2);
			hexagon.scale.set(0.050, 0.050, 0.050);
			markers_group.add(hexagon);
		}
		return markers_group;
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||











	function key_do_something(key) {
		//console.log(key);
		let e = Object.keys(key);

		if(menus.hasOwnProperty(e)){
			menus[e].object.toggle_state();
		}else{
			state_keys_magic[e](key[e]);
		}
		log.state_keys.echo([e,key[e]]);
	}

	state_keys = {};

  gen_keys = {
		'a': {'move': -1},
		'd': {'move': 1},
	}

	function move(dir) {
		console.log('moved', dir);
	}






	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function build_gui() {
		gui = new GUI();
		let general = gui.addFolder("General Options");//.toggleHide();
		general.add(vars, 'show_lines').name('Guide Lines(1)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_lines').override(value);
		}).listen();
		general.add(vars, 'show_tiles').name('Sectors(2)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tiles').override(value);
		}).listen();
		general.add(vars, 'show_grid_points').name('Grid Vertices(3)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_grid_points').override(value);
		}).listen();

		let view = gui.addFolder("View Options");//.toggleHide();
		view.add(vars, 'traversal_rate', 1, 10).step(0.1).name('Move distance [km]').listen();
		view.add(vars, 'threshold_size', 1, 100).step(1).name('Tangent distance [km]').listen();
		view.add(vars, 'view_flip').name('Flip Orientation').listen();
		view.add(vars, 'view_to_threshold').name('Orient to Curve').listen();

		let tile = gui.addFolder("Sector Options");
		tile.add(vars, 'show_tile_planes').name('Planes(4)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tile_planes').override(value);
		}).listen();
		tile.add(vars, 'show_tile_fills').name('Shapes(5)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tile_fills').override(value);
		}).listen();
		tile.add(vars, 'show_tile_lines').name('Paths(6)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tile_lines').override(value);
		}).listen();
		tile.add(vars, 'show_tile_places').name('Places(7)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tile_places').override(value);
		}).listen();
		tile.add(vars, 'show_tile_depths').name('Depths(8)').onChange(function (value) {
			Object.values(state_keys).find(o => o.name === 'show_tile_depths').override(value);
		}).listen();

		gui.close();
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function loadSVG_sub(url) {
		const loader = new SVGLoader();

		loader.load(url, function (data) {
			const paths = data.paths;
			let geoms = [];
			let fillColor = '0x00FF00';
			let opacity = 0.5;

			for (let i = 0; i < paths.length; i++) {
				const path = paths[i];
				fillColor = path.userData.style.fill;
				opacity = (path.userData.style.opacity !== undefined) ? path.userData.style.opacity : 1;
				const path_shape = path.toShapes(true);
				const mesh_geometry = new THREE.ShapeGeometry(path_shape);
				geoms.push(mesh_geometry);
			}

			const material = new THREE.MeshBasicMaterial({
				color: new THREE.Color().setStyle(fillColor),
				opacity: opacity,
				transparent: true,
				side: THREE.DoubleSide,
			});

			const g = mergeBufferGeometries(geoms);
			g.computeBoundingSphere();
			g.center();
			g.rotateX(Math.PI / 2);
			let map_mesh = new THREE.Mesh(g, material);
			north_mark.add(map_mesh);
			north_mark.scale.set(0.01, 0.01, 0.01);
			north_mark.position.setY(0.025);
		});
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function init() {
		const log_vars = [
			'pos',
			'zoom',
			'touching',
			'keys',
			'state_keys',
			'json',
			'info',
			'tile',
			'guide',
			'place',
			'click',
			'nav',
			'selection',
			'region',
			'special'
		];

		for (let e of log_vars) {
			log[e] = (new log_var(e))
		}
		vars.user.zoom = vars.view.base_pos;

		//log.info.echo(['init map_points count: ' + map_points.geometry.attributes.position.count]);

		//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
		function translateAction(type, deltaX, deltaY, object) {
			if (type === 'drag') {
				//#v.copy(vars.user.position);
				object.rotateOnWorldAxis(u, deltaX / 100);
				object.rotateX(deltaY / 100);
				// object.position.x += (-deltaX / (200/cam_base_pos.z));
				// object.position.y += (deltaY / (200/cam_base_pos.z));
				object.updateMatrixWorld();
			}

			if (type === 'zoom') {
				cam_base_pos.multiplyScalar(1 + (deltaY / 200));
				let zz = cam_base_pos.z.toFixed(2);
				vars.user.zoom = cam_base_pos.z;
				vars.user.zoom_level = vars.view.get_zoom(vars.user.zoom / vars.view.base_pos);
				log.zoom.echo([zz, 'level-' + vars.user.zoom_level]);

			} else {
				log.zoom.unwatch();
			}

			if (type === 'clicked') vars.user.mouse.clicked = true;

			vars.user.mouse.state = type;
			vars.user.mouse.x = (deltaX / vars.view.width) * 2 - 1;
			vars.user.mouse.y = (-deltaY / vars.view.height) * 2 + 1;

		}

		//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
		function getKeyActions(raw) {

			Object.keys(state_keys).forEach(key => state_keys[key].set(raw.includes(key)))

			let pk = Object.keys(gen_keys);
			let dpk = pk.filter(a => raw.includes(a));

			if (dpk.length > 0) {
				dpk.forEach(key => key_do_something(gen_keys[key]));
				log.keys.echo(dpk);
			} else {
				log.keys.unwatch();
			}

		}

		//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
		camera = new THREE.PerspectiveCamera(50, vars.view.width / vars.view.height, 1, 1000);
		scene = new THREE.Scene();
		scene.background = new THREE.Color(vars.env_color);

		user_position_marker = make_user_position_mark(1);
		user_mouse_marker = make_user_position_mark(1);

		nice_arrow = make_pointer_arrow();
		nice_arrow_mini = make_pointer_arrow();
		nice_arrow_mini.scale.set(0.01, 0.01, 0.01);
		nice_arrow_mini.material.color.offsetHSL(0, 0, 1.0);

		north_mark = new THREE.Object3D();
		loadSVG_sub('./img/north.svg');
		scene.add(north_mark);

		const triangle = make_markers_group();

		scene.add(map_group);

		scene.add(arrow_helper);
		scene.add(triangle);
		scene.add(arrow_helper_2);
		scene.add(arrow_helper_3);
		scene.add(user_position_marker);
		scene.add(user_mouse_marker);
		scene.add(nice_arrow);
		scene.add(nice_arrow_mini);

		user_position_marker.position.copy(vars.user.position);

		const light = new THREE.PointLight(0xFFFFFF, 2); ///0xDB8B00
		light.position.set(0, 1000);
		scene.add(light);

		//scene.fog = new THREE.Fog( vars.env_color, 0.015, 20 );

		renderer = new THREE.WebGLRenderer(); //{powerPreference: "high-performance", antialias: true});
		renderer.setPixelRatio(2);//window.devicePixelRatio);//(2)
		renderer.setSize(vars.view.width, vars.view.height);
		document.body.appendChild(renderer.domElement);

		dragControls(renderer.domElement, translateAction, cube, {passive: true});//camera_position
		keyControls(window, getKeyActions);

		stats = new Stats();
		// document.body.appendChild(stats.dom);

		raycaster = new THREE.Raycaster();
		raycaster.params.Line.threshold = 0.5;//0.025;

		scene.updateMatrixWorld();

		window.addEventListener('resize', onWindowResize);


		const shape = vars.map.data.map_spec.shape;
		const degre = vars.map.data.map_spec.map_degrees;
		const size = vars.map.s * Math.max(shape.w, shape.h);
		const divisions = (1/degre) * Math.max(shape.w, shape.h);



		vars.view.base_pos = vars.map.s * shape.h; //Math.max(shape.w, shape.h);
		cam_base_pos.setZ(vars.view.base_pos);
		cam_pos.setY(vars.view.base_pos);

	// 		let cam_base_pos = new THREE.Vector3(0, 0, vars.view.base_pos);
	// let cam_pos = new THREE.Vector3(0, vars.view.base_pos, 0);

		const col_xy = new THREE.Color("hsl(306, 100%, 30%)");
		const col_gd = new THREE.Color("hsl(306, 100%, 20%)");

		gridHelper = new THREE.GridHelper( size, divisions, col_xy, col_gd );
		scene.add( gridHelper );

		//make_menus();

	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function get_point_on_guide(world_point, guide_id) {
		const guide = get_guide(guide_id);
		const guide_curve = guide.userData.guide.curve;
		let searchArray = [];
		let uPosition = null;
		let c = null;
		// Loop through curve.points to find our final point
		// bear in mind offset at 'l' which calculates the min distance via the number of points on the line.
		for (let i = 0; i < guide_curve.points.length; i++) {
			searchArray.push(guide_curve.points[i]);
			const gl = guide_curve.getLength();
			let d = guide_curve.points[i].distanceTo(world_point);
			let l = 1 / (guide_curve.points.length / gl);
			if (d < l && searchArray.length > 1) {
				let curve2 = new THREE.CatmullRomCurve3(searchArray);
				curve2.arcLengthDivisions = searchArray.length * vars.curve_segments;
				curve2.updateArcLengths();
				uPosition = curve2.getLength() / gl;
				let t = guide_curve.getTangentAt(uPosition);
				k.subVectors(world_point, guide_curve.points[i]).normalize();
				let sign = Math.sign(k.dot(t));
				uPosition = (curve2.getLength() / gl) + ((d / gl) * sign);
				uPosition = UTIL.naturalize_on_loop(uPosition, true);
				break;
			}
		}

		if (uPosition !== null) {
			let um = guide_curve.getUtoTmapping(uPosition);
			c = guide_curve.getPoint(um);
			map_group.localToWorld(c);
		}

		return [uPosition, c];
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function move_point_on_curve(dir, key_action = true) {
		if (vars.user.selected_guide === null) return;
		const guide = get_guide(vars.user.selected_guide);
		const guide_curve = guide.userData.guide.curve;
		const centroid = guide.userData.guide.centroid.clone();
		const L = 1 / UTIL.deg_to_km(guide_curve.getLength());
		const D = vars.traversal_rate * L;

		if (key_action) {
			vars.user.guide_position_scalar += D * dir;
			update_nav(D * dir);
			vars.user.guide_position_scalar = UTIL.naturalize_on_loop(vars.user.guide_position_scalar);
		} else {
			vars.user.guide_position_scalar = dir;
		}

		const guide_position_scalar = vars.user.guide_position_scalar;
		const thresh = vars.threshold_size;

		let a = UTIL.naturalize_on_loop(guide_position_scalar - (thresh * D), true);
		let b = UTIL.naturalize_on_loop(guide_position_scalar + (thresh * D), true);

		let ua = guide_curve.getUtoTmapping(a);
		let ub = guide_curve.getUtoTmapping(b);
		let ac = guide_curve.getPoint(ua);
		let bc = guide_curve.getPoint(ub);
		map_group.localToWorld(ac);
		map_group.localToWorld(bc);

		let um = guide_curve.getUtoTmapping(guide_position_scalar);
		let c = guide_curve.getPoint(um);
		map_group.localToWorld(c);

		markers_group.children[0].position.copy(ac);
		markers_group.children[1].position.copy(bc);

		map_group.localToWorld(centroid);

		k.subVectors(ac, bc).multiplyScalar(0.5).add(bc);
		vars.user.position.copy(k);
		arrow_helper.position.copy(k);
		position_user(k, 'move');

		cube.getWorldDirection(v);

		let view_dir = vars.view_flip ? 1 : -1;

		if (vars.view_to_threshold) {
			w.subVectors(ac, bc).normalize();
			k.crossVectors(u, w).multiplyScalar(view_dir).normalize();
			arrow_helper.setDirection(k);
		} else {
			k.subVectors(centroid, vars.user.position.clone()).multiplyScalar(view_dir).normalize();
			arrow_helper.setDirection(k);
		}

		nice_arrow_mini.position.copy(vars.user.position);
		north_mark.position.copy(un.clone().multiplyScalar(user_position_marker.userData.radius * -2).add(vars.user.position));

		w.crossVectors(u, v);
		let angle = w.dot(k);
		cube.rotateOnWorldAxis(u, angle);
		cube.updateMatrixWorld();
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function onWindowResize() {
		vars.view.reset();
		camera.aspect = vars.view.width / vars.view.height;
		camera.updateProjectionMatrix();
		renderer.setSize(vars.view.width, vars.view.height);
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function position_user(target_pos, mode = 'none') {
		if (mode === 'clicked') {
			if (vars.user.touching_guide === null) {
				vars.user.selected_guide = null;
				const boxArray = [...svg.getElementsByTagName('g')];
				for (let g of boxArray) g.style.display = "none";
			} else {
				vars.user.selected_guide = vars.user.touching_guide;
				k.copy(vars.user.pointer_position);
				map_group.worldToLocal(k);
				let c_pos = get_point_on_guide(k, vars.user.selected_guide);
				vars.user.guide_position_scalar = c_pos[0];
				const guide = get_guide(vars.user.selected_guide);
				set_guide_position_to_nav_bar(vars.user.guide_position_scalar, guide.userData.guide.length);
				move_point_on_curve(0, true);
			}

			v.copy(vars.user.pointer_position);
			vars.user.position.copy(v);

			k.set(0, 0.05, 0);
			v.add(k);

			arrow_helper.position.copy(v);
			arrow_helper_2.position.copy(v);
			arrow_helper_3.position.copy(v);

			camera.getWorldDirection(k);
			w.crossVectors(k, u);
			k.projectOnPlane(u);

			arrow_helper.setDirection(u);
			arrow_helper_2.setDirection(w);
			arrow_helper_3.setDirection(k);
			north_mark.position.copy(un.clone().multiplyScalar(user_position_marker.userData.radius * -1.2).add(v));
			nice_arrow.position.copy(v);
			user_position_marker.position.copy(v);
		}
		if (mode === 'move') {
			user_mouse_marker.position.copy(target_pos);
		}
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function animate() {
		requestAnimationFrame(animate);
		render();
		stats.update();
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	let vn = 0, vm = 0;
	let ctr = {v:0,p:0,n:0,t:0,t2:0,i:1,j:0,s:0,f:0};

	function pulse(a){
		ctr.t = a-ctr.t;
		if(ctr.f === ctr.p){
			ctr.t2 = a-ctr.t2;
			ctr.p = (ctr.f+vars.update_frequency);
			if(!vars.update_pause) frame();
			ctr.t2 = a;
		}else{
			ctr.f++;
		}
		ctr.t = a;
	}

	function frame(){
		log.special.echo([vars.auxillary]);
		ctr.v++;

		//map_tiles_group.children.forEach(t => t.update_frame('sst',ctr.v));
		map_tiles_group.children.forEach(t => t.update_frame('wind', ctr.v));
			  //if(ctr.v % dat.POINT_IDLE === 0) subvert(points.geometry);
		//console.log(ctr.v, "frame");
	}


	let selected_regions = [];

	function render(a) {
		pulse(a);

		v_q.setFromUnitVectors(u, vars.user.position.clone().normalize());
		cam_pos.lerp(cam_base_pos.clone().applyQuaternion(cube.quaternion), 0.1);
		camera.up.lerp(u.clone().applyQuaternion(cube.quaternion), 0.1);
		camera.position.addVectors(cam_pos, vars.user.position);
		camera.lookAt(vars.user.position);
		raycaster.setFromCamera(vars.user.mouse, camera);
		camera.updateMatrix();
		camera.updateMatrixWorld();

		camera_frustum.setFromProjectionMatrix(camera_frustum_m.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
		//tile.display = camera_frustum.containsPoint(k);

		vars.user.local_position.subVectors(camera.position, vars.user.position).multiplyScalar(0.75).add(vars.user.position);
		map_group.worldToLocal(vars.user.local_position);

		let intersects = raycaster.intersectObject(map_plane);//, false);
		if (intersects.length > 0) {
		  v.copy(intersects[0].point);
		  vars.user.pointer_position.copy(v);
		  map_group.worldToLocal(v);
		  log.pos.echo(['LON ' + v.x.toFixed(4), 'LAT ' + v.y.toFixed(4), vars.user.mouse.state]);
		}

		document.body.style.cursor = 'default';
		vars.user.touching_guide = null;


		selected_regions = [];
		//let zooms = [];
		for (let tile of map_tiles_group.children) {
			v.subVectors(vars.user.local_position, tile.center);

			//it's not actually a normalization
			// vn = UTIL.normalize_val(v.length()*vars.map.s, 0.1, vars.view.base_pos);  //vars.map.s);
			// vm = Math.round(6 * (1 - vn));//(1 - (Math.round(vn))); // # * vars.map.s) / 5));


			vm = vars.view.get_zoom((v.length() * 6.0) / vars.view.base_pos)*1;
			//zooms.push(vm);//v.length());//,vn)
			//
			//
			// if (vm < 1) vm = 1;
			// if (vm > 5) vm = 5;

			if (tile.zoom_level !== vm) {
				tile.zoom_level = vm;
				tile.plane.material.opacity = tile.zoom_level / 5;
				if (tile.zoom_level >= 1) tile.update(tile.zoom_level);
				const c = Object.keys(tile.data_keys).filter((k) => tile.data_keys[k].hasOwnProperty('spc') === true);
				tile.update_data(c);
				// console.log(c);
			}
			//this is ticks for the entire group of tiles so the output ovwrrwrites
			if(tile.hasOwnProperty('protected_regions')){
				let g_pl = raycaster.intersectObject(tile.protected_regions);
				if(g_pl.length){
					g_pl.forEach(p => selected_regions.push(p.object.userData.area.NAME));
				}
			}

			if (tile.zoom_level > 2 && vars.user.mouse.state !== 'drag') {
				intersects = raycaster.intersectObject(tile.plane);
				if (intersects.length) {
					//const p = Object.entries(intersects);//.map(([k,v]) =>)
					//log.info.echo(p);
					if(tile.hasOwnProperty('places')){
						let g_pl = raycaster.intersectObject(tile.places);
						if(g_pl.length){
							g_pl.forEach(p => log.place.echo(p.object.userData.place.name_short()));
						}else{
							log.place.unwatch();
						}
					}

					if(tile.hasOwnProperty('lines')){
						if(vars.map.data.map_spec.includes.includes('guides')) {
							let g = raycaster.intersectObject(tile.lines).filter(e => e.object.visible);
							if (g.length) {
								let sel = g[0].object.userData.line_shape;
								if (map_guides.userData.shapes.includes(sel)) {
									position_user(g[0].pointOnLine, 'move');
									vars.user.touching_guide = sel;
									document.body.style.cursor = 'pointer';
								}
							}
						}
					}
					// 	//basically here to see any lines and at any level of depth;
				// 	let g = raycaster.intersectObject(tile.lines).filter(e => e.object.visible);
				// 	if(g.length){
				// 		let sel = g[0].object.userData.line_shape;
				// 		if(map_guides.userData.shapes.includes(sel)){
				// 			position_user(g[0].pointOnLine,'move');
				// 			vars.user.touching_guide = sel;
				// 			document.body.style.cursor = 'pointer';
				// 		}
				}
				// }else{
				// 	//log.info.unwatch();
				// }
			}
		}

		//log.touching.echo(zooms);

		if(selected_regions.length){
			selected_regions.sort();
			log.region.echo(selected_regions);
		}else {
			log.region.unwatch();
		}

		log.guide.echo([vars.user.touching_guide]);

		if(vars.user.mouse.clicked){
			log.click.echo(['consumed('+vars.clicks+') clicks']);
			vars.clicks ++;
			vars.user.mouse.clicked = false;
			position_user(null,'clicked');
		}

		let az = (vars.user.zoom / vars.view.base_pos)*0.02;
		north_mark.scale.set(az,az,az);
		nice_arrow.scale.set(az,az,az);
		nice_arrow_mini.scale.set(az,az,az);

		log_display();
		renderer.render(scene, camera);
	}

	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function start() {
		build_gui();
		init();
		animate();
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function build_map_group(map_data_group) {
		// map_group = new THREE.Group();
		// map_tiles_group = new THREE.Group();
		//set map bounds and basic placement.
		//build critical vertices.
		//get instances of tiles with data.
		//build motion guides.
		vars.base_url = './data/'+map_data_group.map_spec.name+'/';

		const map_deg = map_data_group.map_spec.map_degrees;
		vars.map.map_deg = map_deg;
		vars.map.rect = map_data_group.map_spec.rect;
		vars.map.w = (vars.map.rect.max_X-vars.map.rect.min_X);//*(1/map_deg);
		vars.map.h = (vars.map.rect.max_Y-vars.map.rect.min_Y);//*(1/map_deg);
		vars.map.sectors = (vars.map.w * (1/map_deg))*( vars.map.h * (1/map_deg));
		vars.map.w_offset = (vars.map.rect.min_X) - (vars.map.w / -2);
		vars.map.h_offset = (vars.map.rect.min_Y) - (vars.map.h / -2);
		vars.map.coverage = map_data_group.map_data_index.length/vars.map.sectors;

		k.set(vars.map.w_offset, vars.map.h_offset, 0.0);
		vars.map.c = k.clone();

		vars.map.data = map_data_group;

		//console.log(vars.map);

		const geometry = new THREE.PlaneGeometry(vars.map.w, vars.map.h, 1, 1);
		map_plane = new THREE.Mesh(geometry, MATS.mapPlaneMaterial);
		map_plane.userData.name = 'map_plane';
		map_plane.position.copy(k);

		const map_max_dim = vars.map.w;// > vars.map.h ? vars.map.w : vars.map.h
		//+++++++++++++++++++++++++++++
		function build_map_sectors_and_tiles(data_index) {
			// now :{'id': 47, 'lv': [1, 2, 3, 4], 'dt': ['depths'], 'fl': ['urban'], 'au': ['places'], 'gd': ['guide-9']}
			vars.map.vertices = [];
			let sx = 0, sy = 0;

			for (let i = 0; i < vars.map.sectors; i++) {
				let x = i % (map_max_dim * (1/map_deg));
				let y = Math.floor(i / (map_max_dim * (1/map_deg)));
				sx = vars.map.rect.min_X + x*map_deg;
				sy = vars.map.rect.max_Y - y*map_deg;
				w.set(sx, sy, 0.0);
				vars.map.vertices.push(w.clone());

				const has_key = data_index.find(g => g.id === i);
				if(has_key) {
					let tile_vertices = [
						w.clone(),
						w.clone().setY(w.y - map_deg),
						w.clone().setX(w.x + map_deg).setY(w.y - map_deg),
						w.clone().setX(w.x + map_deg)
					]

					let loc = [vars.map.rect.min_X + x, vars.map.rect.min_Y + y];
					let name = 'M' + loc[0] + '_' + loc[1] + '_' + i;
					const new_tile = new classes.sector(name, loc, i, tile_vertices, has_key, vars, show_load);
					map_tiles_group.add(new_tile);
				}

			}

			let colors = new Float32Array(vars.map.vertices.length * 3);
			for (let c = 0; c < vars.map.vertices.length * 3; c += 3) {
				colors[c] = 1;
				colors[c + 1] = 0;
				colors[c + 2] = 1;
			}

			let pointsGeometry = new THREE.BufferGeometry().setFromPoints(vars.map.vertices);
			pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
			map_points = new THREE.Points(pointsGeometry, MATS.pointsMaterial);
		}
		//+++++++++++++++++++++++++++++
		function build_map_guides(data) {
			map_guides = new THREE.Group();
			let map_guides_vertices = [];
			let map_guides_shapes = [];

			for (let shape of data) {
				const points = shape.geom; //[2];
				let vertices = [];

				for (let p = 0; p < points.length; p += 2) {
					v.set(points[p], points[p + 1], 0.005);
					vertices.push(v.clone());
				}

				// vertices.reverse();
				// vertices.pop();
				const is_closed = shape.closed;

				if (vertices.length > 0) {
					const curve = new THREE.CatmullRomCurve3(vertices, true);
					curve.closed = is_closed;// shape[4];
					const len = curve.getLength();
					curve.arcLengthDivisions = vertices.length * vars.curve_segments;
					curve.updateArcLengths();

					let even_points = curve.getSpacedPoints(vertices.length / 2);// / 8);

					if (even_points.length > 1) {
						//#alert(shape[4]);
						if(is_closed) even_points.pop();
						const fine_curve = new THREE.CatmullRomCurve3(even_points, true);
						fine_curve.closed = is_closed;// shape[4];
						fine_curve.arcLengthDivisions = even_points.length * vars.curve_segments;
						fine_curve.updateArcLengths();

						const curvePoints = fine_curve.getPoints(vertices.length * vars.curve_segments);
						const geometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
						const curveObject = new THREE.Line(geometry, MATS.mapGuidesMaterial);

						for (let p of fine_curve.points) {
							map_guides_vertices.push(p);
							map_guides_shapes.push(shape.shape);
						}

						curveObject.userData.guide = {
							'shape': shape.shape,
							'curve': fine_curve,
							'length': len.toFixed(4),
							'centroid': new THREE.Vector3().fromArray(UTIL.get_centroid(curvePoints)),
							'linked_places': []
						}
						map_guides.add(curveObject);
					}
				}
			}

			map_guides.userData.shapes = map_guides_shapes;

			let pointsGeometry = new THREE.BufferGeometry().setFromPoints(map_guides_vertices);
			map_guides_verts = new THREE.Points(pointsGeometry, MATS.mapGuideVerticesMaterial);
		}
		//+++++++++++++++++++++++++++++
		console.log('map_data_group.map_guides',map_data_group.map_guides);
		if(map_data_group.map_guides) {
			build_map_guides(map_data_group.map_guides);
			map_group.add(map_guides_verts);
			map_group.add(map_guides);
		}

		build_map_sectors_and_tiles(map_data_group.map_data_index);

		const brw = map_data_group.map_spec.includes_attributes;

		// #// GETTING TIME INDICES HERE
		const indices_load = Object.keys(brw)
			.filter((k) => brw[k].hasOwnProperty('time'))
			.map((k) => [`${k}_time_index`,`./data/med_mini_halfdeg_feb_2/${k}-indices.json`]);

		fetchAll(indices_load, show_load).then(result => {
			vars.data.update_frames = result;
			Object.keys(result).forEach((k) => vars.data[k] = result[k]);
		});

		map_group.add(map_points);
		map_group.add(map_tiles_group);
		map_group.add(map_plane);
		map_plane.visible = false;

		map_group.rotateX(Math.PI / -2);
		map_group.translateX(-vars.map.w_offset  * vars.map.s);
		map_group.translateY(-vars.map.h_offset  * vars.map.s);
		map_group.scale.set(vars.map.s, vars.map.s, vars.map.s);

		//console.log("total",vars.map.w * vars.map.h, "coverage", (vars.map.coverage*100).toFixed(2), '%');
		//console.log(vars.map);


		start();
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function make_menus(default_menu){
		// is default or not?
		let menu = default_menu[0];
		let struct = default_menu[1];
		let active = vars.map.hasOwnProperty('data') ? vars.map.data.map_spec.includes : [];

		menus = methods.make_ui_layers_panel(ui_el, state_keys_magic, active, menu, struct);

		for(let m in menus){
			state_keys[menus[m].key] = new classes.mini_toggle(m, vars, key_do_something, menus[m].default);
			menus[m].object.toggle_state('initial');
		}
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	function add_maps_to_menus(data, default_menu=null){
		function map_info_filter(data){
		let pre = '';
		for(let d in data){
			pre += d+': ';
			if(typeof(data[d]) === 'object'){
				for(let e in data[d]) pre += data[d][e]+' ';
			}else{
				pre += data[d]+' ';
			}
			pre+='</br>';
		}
		return(pre);
	}


		const zone = data.map_information.maps;
		let dpk = {root:{maps:{}}};
		let map_menu = {
			root:{
				name:'menu',
				type:'static',
				default:true
			},
			maps:{
				name:'maps',
				type:'static',
				default:true
			}
		};
		if(default_menu){
			dpk = default_menu[1];
			dpk.root.maps = {};
			map_menu = default_menu[0];
			map_menu['maps'] = {
				name:'maps',
				type:'static',
				default:false
			}
		}
		for(let map in zone){
			map_menu[zone[map].name] = {
				name:zone[map].name,
				type:'static',
				default:false
			};
			map_menu[zone[map].name+'-data'] = {
				name:zone[map].name+'-data',
				type:'static',
				asset: map_info_filter(zone[map]),
				default:true
			}
			map_menu[zone[map].name+'-link'] = {
				name:zone[map].name+'-link',
				type:'static',
				asset:'[open]',
				link:`?map=${zone[map].name}`,
				default:true
			}
			dpk.root.maps[zone[map].name] = {};
			dpk.root.maps[zone[map].name][zone[map].name+'-data'] = {};
			dpk.root.maps[zone[map].name][zone[map].name+'-link'] = {};
		}
		return [map_menu, dpk];
	}
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	const params = new Proxy(new URLSearchParams(window.location.search), {
  	get: (searchParams, prop) => searchParams.get(prop),
	});
	const map_name = params.map;
	//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	if(map_name){

		const base_map_resources = [
			['map_spec', './data/'+map_name+'/map-spec.json'],
			['map_data_index', './data/'+map_name+'/map-digest.json'],
			['map_guides','./data/'+map_name+'/guides.json'],
			['map_information', './data/obspkg-maps.json']
		];

		fetchAll(base_map_resources, show_load).then(result => {
			build_map_group(result);
			make_menus(add_maps_to_menus(result, methods.get_menu_defaults()))
		});

	}else{

		const base_map_resources = [
			['map_information', './data/obspkg-maps.json']
		];

		fetchAll(base_map_resources, show_load).then(result => {
			make_menus(add_maps_to_menus(result));
		});

	}




</script>
</body>
</html>
